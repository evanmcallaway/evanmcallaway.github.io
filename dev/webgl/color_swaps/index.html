<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Replacing Colors with WebGL</title>
    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
    <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
    <link rel="preload" as="style" href="/layout/layout.css">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
    <link rel="stylesheet" href="/layout/layout.css">

    <link rel="preload" as="script" href="/layout/load.js">
    <script src="/layout/load.js" defer></script>

    <script src="color.js"></script>
  </head>

  <script>
    function startCanvases() {
      webGLStart('canvas1', '/dev/images/controller.png', [0xCCD5D9])
      webGLStart('canvas2', '/dev/images/controller.png', [0x336DB7, 0x41B25C, 0xDE322A, 0xECBB0E])
    }
  </script>

  <body style="opacity: 0;" onload="startCanvases()">
    <div class="container">
      <h3>Replacing Colors with WebGL</h3>

      <p>
        This is a dumb prototype of how you can manipulate specific colors in an image using a WebGL fragment shader.  I'm replacing a specific list of colors on each game controller with some arbitrary colors that I'm modulating each frame, but there's no reason you couldn't swap to more specific colors, like the output of a color picker tool.
      </p>

      <p>On the left we're replacing a single color.  One the right we're replacing all four button colors.</p>

      <div class="center-content">
        <canvas id="canvas1" width="320" height="320"></canvas>
        <canvas id="canvas2" width="320" height="320"></canvas>
      </div>

      <div>
        <p>A couple of key things to keep in mind:</p>
        <ul class="browser-default">
          <li>8-bit RGB is typically represented by a color cube with dimensions from 0-255.  Because vectors, WebGL uses a color cube with dimensions from 0-1, so we have to scale our color math proportionally.</li>
          <li>As always, keep in mind that you cannot perform equality operations on floating point values, like the ones in our vectors.  Instead, check for "close enough" matches based on your application's required tolerance.</li>
        </ul>
      </div>

      <h4>Colors to Vectors</h4>

      <p>We need to rescale our colors from 0-255 per dimension to 0-1.  There's a lot of ways to do this but if you already have your color as a number, you can do it quite simply by using a binary AND to grab the digits for each color and then scaling them proportionally.  We've added a 1.0 to the alpha channel to keep our color vectors the same size as texture2D's output.</p>

      <pre>
        <code>
function colorToVector(color) {
  return [
    (color & 0xFF0000) / 0xFF0000,
    (color & 0xFF00)   / 0xFF00,
    (color & 0xFF)     / 0xFF,
    1.0
  ]
}
        </code>
      </pre>

      <p>Keep in mind that WebGL expects you to pass arrays of vectors as one large flat array of values, so don't nest your values in a parent array if you're working with multiple colors.</p>

      <h4>Fragment Shader</h4>

      <p>Swapping colors is really just a matter of looking for a close enough match and using your new color if you find one.</p>

      <pre>
        <code>
#define MAX_COLORS 24
#define COLOR_TOLERANCE 0.000001

precision highp float;
varying vec2 vTex;
uniform sampler2D sampler0;

uniform vec4 u_new_colors[MAX_COLORS];
uniform vec4 u_original_colors[MAX_COLORS];
uniform int u_colors_count;

vec4 colorSwap(vec4 oldColor[MAX_COLORS], vec4 newColor[MAX_COLORS], vec4 imageColor) {
  for (int i = 0; i &lt; MAX_COLORS; i++) {
    if (i &lt; u_colors_count) {
      // Calculate distance^2 to avoid using an expensive square root operation
      vec4 delta = oldColor[i] - imageColor;
      float distSquared = dot(delta, delta);

      if (distSquared &lt; COLOR_TOLERANCE) return newColor[i];
    }
  }
  return imageColor; // No Match, keep the original color
}

void main(void){
  gl_FragColor = colorSwap(u_original_colors, u_new_colors, texture2D(sampler0, vTex));
}
        </code>
      </pre>

      <p>There's no reason that you need to swap to one one specific other color as well.  You could use this same technique to replace a certain color with the colors from another texture in the style of a television studio green screen.</p>

      <p>With a few minor mondifications, you could also swap colors from another source like a video.</p>

      <p>
        The source for his page is available <a href="https://github.com/evanmcallaway/evanmcallaway.github.io/tree/master/dev/webgl/color_swaps">here</a>.
      </p>

      <p>TODOs:</p>
      <ul class="browser-default">
        <li>Add demonstraction of green screen effect.</li>
        <li>Generate better "new" colors or add color picker to live demo.</li>
        <li>Convert colors.js into a module.</li>
        <li>Separate WebGL boilerplate from the meat of the project.</li>
        <li>Expand explanation text.</li>
      </ul>
    </div>
  </body>
</html>